
-There is a interface that all the commands implement.
-There is a packet interpreter that looks at the packet and gives the control to command object to handle the connection
    -The FD is handed over to the packet interpreter as soon as connection is established
    -If first 8 bytes of the FD upon connection is not a recognized command it, will throw an exextion
    -The interpreter consumes the command part of the incommig packet from the FD, then hands over the control to command object


==== Design ===========================================
-Packet Structure
    -8 bytes:Command Name
    -8 Bytes: lenght of metadata(X)
    -X bytes: metadata
    -8 bytes: lenght of payload(Y)
    -Y bytes: payload
    -8byte: commands

-Server:
    -Will be listening on a port
    -Once new connecion arrives, user first 8 bytes to get a command obeject
    -Pass the control to command object

-Command objects:
    -Each Command handler object will have the function named process,
    that will handle the request

-Define a new handler by:
    -Adding it to enum Protocol::PacketType
    -Create a class inheriting from Protocol::Command
    -Add the Command in Protocol::getCommandHandle function

=======================================================

-Commands Workings:
    -Heart beat:
        -This is sent by a client to say a client is alive
    

-Roadmap:
    -Protocols to implement:
        -FTP like protocol
        -Command execution protocol
        -Peer finding protocol
        -Self update protocol
        -Propagation protocol
    -FTP:
        -FTP_ASK
            -Ask for a file
            -Meta: filepath
            -Payload: None
        -FTP_ASK_NF
        -FTP_FILE
        -FTP_FILE_ACK
